# JavaScript中ES6实现继承

# 对象的方法补充

◼ **hasOwnProperty** 

 对象是否有某一个属于自己的属性（不是在原型上的属性） 

◼ **in/for in 操作符** 

 判断某个属性是否在某个对象或者对象的原型上 

◼ **instanceof** 

 用于检测构造函数（Person、Student类）的pototype，是否出现在某个实例对象的原型链上 

◼ **isPrototypeOf** 

 用于检测某个对象，是否出现在某个实例对象的原型链上

![img](https://cdn.nlark.com/yuque/0/2023/png/34886243/1673593765344-ebc03660-51bb-4a82-8115-1ec247a7190f.png)

# 原型继承关系图

## 原型继承关系

![img](https://cdn.nlark.com/yuque/0/2023/png/34886243/1673593859245-2dc81268-728b-402c-8c9c-52a194f6905c.png)

# class方式定义类

## 认识class定义类

◼ 我们会发现，按照前面的构造函数形式创建 **类**，不仅仅和编写普通的函数过于相似，而且代码并不容易理解。 

 在ES6（ECMAScript2015）新的标准中使用了class关键字来直接定义类； 

 但是类本质上依然是前面所讲的构造函数、原型链的语法糖而已； 

 所以学好了前面的构造函数、原型链更有利于我们理解类的概念和继承关系； 

◼ 那么，如何使用class来定义一个类呢？ 

 可以使用两种方式来声明类：类声明和类表达式；

![img](https://cdn.nlark.com/yuque/0/2023/png/34886243/1673593880372-1b58472b-6853-4647-b56c-d4724b690e49.png)

## 类和构造函数的异同

◼ 我们来研究一下类的一些特性： 

 你会发现它和我们的构造函数的特性其实是一致的；

![img](https://cdn.nlark.com/yuque/0/2023/png/34886243/1673593910054-b21d3d78-cc1a-442d-abf8-6699fbdbb182.png)

## 类的构造函数

◼ 如果我们希望在创建对象的时候给类传递一些参数，这个时候应该如何做呢？ 

 每个类都可以有一个自己的构造函数（方法），这个方法的名称是固定的constructor； 

 当我们通过new操作符，操作一个类的时候会调用这个类的构造函数constructor； 

 每个类只能有一个构造函数，如果包含多个构造函数，那么会抛出异常； 

◼ 当我们通过new关键字操作类的时候，会调用这个constructor函数，并且执行如下操作： 

 1.在内存中创建一个新的对象（空对象）； 

 2.这个对象内部的[[prototype]]属性会被赋值为该类的prototype属性； 

 3.构造函数内部的this，会指向创建出来的新对象； 

 4.执行构造函数的内部代码（函数体代码）； 

 5.如果构造函数没有返回非空对象，则返回创建出来的新对象；

## 类的实例方法

◼ 在上面我们定义的属性都是直接放到了this上，也就意味着它是放到了创建出来的新对象中： 

 在前面我们说过对于实例的方法，我们是希望放到原型上的，这样可以被多个实例来共享； 

 这个时候我们可以直接在类中定义；

![img](https://cdn.nlark.com/yuque/0/2023/png/34886243/1673593951380-75127dc1-924c-42be-83d4-6d04c1fd0306.png)

## 类的访问器方法

◼ 我们之前讲对象的属性描述符时有讲过对象可以添加setter和getter函数的，那么类也是可以的：

![img](https://cdn.nlark.com/yuque/0/2023/png/34886243/1673593978793-f9d47b3c-00d2-4720-bcb6-3c5a61f558df.png)

## 类的静态方法

◼ 静态方法通常用于定义直接使用类来执行的方法，不需要有类的实例，使用static关键字来定义：

![img](https://cdn.nlark.com/yuque/0/2023/png/34886243/1673594004608-8b2dafd1-ea08-4c43-aeda-a5f09c6ed00e.png)

# extends实现继承

◼ 前面我们花了很大的篇幅讨论了在ES5中实现继承的方案，虽然最终实现了相对满意的继承机制，但是过程却依然是非常繁琐的。 

 在ES6中新增了使用extends关键字，可以方便的帮助我们实现继承：

![img](https://cdn.nlark.com/yuque/0/2023/png/34886243/1673594021356-4c46a7fd-b77d-4fc9-a6b9-a014b60ae9b5.png)

## super关键字

◼ 我们会发现在上面的代码中我使用了一个super关键字，这个super关键字有不同的使用方式： 

 注意：在子（派生）类的构造函数中使用this或者返回默认对象之前，必须先通过super调用父类的构造函数！ 

 super的使用位置有三个：子类的构造函数、实例方法、静态方法；

![img](https://cdn.nlark.com/yuque/0/2023/png/34886243/1673594097152-efd1c665-e48c-4f55-b1ea-93a56f196ae0.png)

## 继承内置类

◼ 我们也可以让我们的类继承自内置类，比如Array：

![img](https://cdn.nlark.com/yuque/0/2023/png/34886243/1673594118597-3260d7ec-55c4-4129-a194-3d89b80c75d4.png)

# 多态概念的理解

◼ 面向对象的三大特性：封装、继承、多态。 

 前面两个我们都已经详细解析过了，接下来我们讨论一下JavaScript的多态。 

◼ JavaScript有多态吗？ 

 维基百科对多态的定义：**多态**（英语：polymorphism）指为不同数据类型的实体提供统一的接口，或使用一个单一的符号 

来表示多个不同的类型。 

 非常的抽象，个人的总结：不同的数据类型进行同一个操作，表现出不同的行为，就是多态的体现。 

◼ 那么从上面的定义来看，JavaScript是一定存在多态的。

![img](https://cdn.nlark.com/yuque/0/2023/png/34886243/1673594061729-61d64aaf-b41f-430c-acf7-46dd5953fa34.png)