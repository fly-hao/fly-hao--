# this指向全解

# this的绑定规则

### this到底指向什么呢?

◼ **我们先来看一个让人困惑的问题：** 

 定义一个函数，我们采用三种不同的方式对它进行调用，它产生了三种不同的结果 

◼ **这个的案例可以给我们什么样的启示呢？** 

 1.函数在调用时，JavaScript会默认给this绑定一个值； 

 2.this的绑定和定义的位置（编写的位置）没有关系； 

 3.this的绑定和调用方式以及调用的位置有关系； 

 4.this是在运行时被绑定的； 

◼ **那么this到底是怎么样的绑定规则呢？一起来学习一下吧** 

 绑定一：默认绑定； 

 绑定二：隐式绑定； 

 绑定三：显示绑定； 

 绑定四：new绑定；

![img](https://cdn.nlark.com/yuque/0/2023/png/34886243/1673587160576-18cdc383-d00d-4b8c-a221-483454335211.png)

### 规则一：默认绑定

◼ **什么情况下使用默认绑定呢？独立函数调用。** 

 独立的函数调用我们可以理解成函数没有被绑定到某个对象上进行调用； 

◼ 我们通过几个案例来看一下，常见的默认绑定

![img](https://cdn.nlark.com/yuque/0/2023/png/34886243/1673587187597-1813cef4-7631-4602-9d8f-5dfbe5642bb4.png)

### 规则二：隐式绑定

◼ **另外一种比较常见的调用方式是****通过某个对象进行调用****的：** 

也就是它的调用位置中，是通过某个对象发起的函数调用。 

◼ 我们通过几个案例来看一下，常见的默认绑定

![img](https://cdn.nlark.com/yuque/0/2023/png/34886243/1673587216134-3a0bba50-a74e-4eae-bdca-2f4c11a28e5c.png)

### 规则三：显式绑定

◼ **隐式绑定有一个前提条件：** 

 必须在调用的对象内部有一个对函数的引用（比如一个属性）； 

 如果没有这样的引用，在进行调用时，会报找不到该函数的错误； 

 正是通过这个引用，间接的将this绑定到了这个对象上； 

◼ **如果我们不希望在** **对象内部** **包含这个****函数的引用****，同时又希望在这个对象上****进行强制调用****，该怎么做呢？** 

◼ **JavaScript所有的函数都可以使用****call和apply方法****。** 

 第一个参数是相同的，要求传入一个对象； 

✓ 这个对象的作用是什么呢？就是给this准备的。 

✓ 在调用这个函数时，会将this绑定到这个传入的对象上。 

 后面的参数，apply为数组，call为参数列表； 

![img](https://cdn.nlark.com/yuque/0/2023/png/34886243/1673587292615-190c1b11-3a37-400f-a8c2-bbbac127ae3a.png)

◼ 因为上面的过程，我们明确的绑定了this指向的对象，所以称之为 **显式绑定**。

# apply/call/bind

◼ **通过call或者apply绑定this对象** 

 显示绑定后，this就会明确的指向绑定的对象 

![img](https://cdn.nlark.com/yuque/0/2023/png/34886243/1673587316708-8a65d74a-faf8-4f25-838e-b1975d0e2645.png)

◼ **如果我们希望一个函数总是显示的绑定到一个对象上，可以怎么做呢？** 

 使用bind方法，bind() 方法创建一个新的绑定函数（bound function，BF）； 

 绑定函数是一个 exotic function object（怪异函数对象，ECMAScript 2015 中的术语） 

 在 bind() 被调用时，这个新函数的 this 被指定为 bind() 的第一个参数，而其余参数将作为新函数的参数，供调用时使用。

![img](https://cdn.nlark.com/yuque/0/2023/png/34886243/1673587323574-7fb66962-d45f-4272-9b27-d32ad468602d.png)

# this绑定优先级

### 内置函数的绑定思考

◼ **有些时候，我们会调用一些JavaScript的内置函数，或者一些第三方库中的内置函数。** 

 这些内置函数会要求我们传入另外一个函数； 

 我们自己并不会显示的调用这些函数，而且JavaScript内部或者第三方库内部会帮助我们执行； 

 这些函数中的this又是如何绑定的呢？ 

◼ **setTimeout、数组的forEach、div的点击**

![img](https://cdn.nlark.com/yuque/0/2023/png/34886243/1673587362554-eb236358-3727-4880-a486-9f25a6bef99f.png)

### new绑定

◼ **JavaScript中的函数可以当做一个类的构造函数来使用，也就是使用new关键字。** 

◼ **使用new关键字来调用函数是，会执行如下的操作：** 

 1.创建一个全新的对象； 

 2.这个新对象会被执行prototype连接； 

 3.这个新对象会绑定到函数调用的this上（this的绑定在这个步骤完成）； 

 4.如果函数没有返回其他对象，表达式会返回这个新对象；

![img](https://cdn.nlark.com/yuque/0/2023/png/34886243/1673587411615-0b7ac30c-ccb1-4762-a32f-88d77c8b5fff.png)

### 规则优先级

◼ **学习了四条规则，接下来开发中我们只需要去查找函数的调用应用了哪条规则即可，但是如果一个函数调用位置应用了多** 

**条规则，优先级谁更高呢？** 

◼ **1.默认规则的优先级最低** 

 毫无疑问，默认规则的优先级是最低的，因为存在其他规则时，就会通过其他规则的方式来绑定this 

◼ **2.显示绑定优先级高于隐式绑定** 

 代码测试 

◼ **3.new绑定优先级高于隐式绑定** 

 代码测试 

◼ **4.new绑定优先级高于bind** 

 new绑定和call、apply是不允许同时使用的，所以不存在谁的优先级更高 

 new绑定可以和bind一起使用，new绑定优先级更高 

 代码测试

# 绑定之外的情况

### this规则之外 - 忽略显示绑定

◼ **我们讲到的规则已经足以应付平时的开发，但是总有一些语法，超出了我们的规则之外。（神话故事和动漫中总是有类似这样的** 

**人物）** 

◼ **情况一：如果在显示绑定中，我们传入一个null或者undefined，那么这个显示绑定会被忽略，使用默认规则：**

![img](https://cdn.nlark.com/yuque/0/2023/png/34886243/1673587514312-f55fed2a-91e2-4e30-9673-2ff2e1287e0b.png)

### this规则之外 - 间接函数引用

◼ **情况二：创建一个函数的** **间接引用****，这种情况使用默认绑定规则。** 

 赋值(obj2.foo = obj1.foo)的结果是foo函数； 

 foo函数被直接调用，那么是默认绑定；

![img](https://cdn.nlark.com/yuque/0/2023/png/34886243/1673587554747-4ec06d7c-e1f8-4a38-a64f-0ce03434f6dd.png)

# 箭头函数

## 箭头函数的使用

◼ **箭头函数是ES6之后增加的一种编写函数的方法，并且它比函数表达式要更加简洁：** 

 箭头函数不会绑定this、arguments属性； 

 箭头函数不能作为构造函数来使用（不能和new一起来使用，会抛出错误）； 

◼ **箭头函数如何编写呢？** 

 (): 函数的参数 

 {}: 函数的执行体

![img](https://cdn.nlark.com/yuque/0/2023/png/34886243/1673587572984-56b355a8-c54a-46a5-bbfd-fac39d5ec360.png)

## 箭头函数的编写优化

◼ **优化一: 如果只有一个参数()可以省略** 

![img](https://cdn.nlark.com/yuque/0/2023/png/34886243/1673587604989-a4d83fad-2144-4b63-a6e4-e99e89b5930c.png)

◼ **优化二: 如果函数执行体中只有一行代码, 那么可以省略大括号** 

 并且这行代码的返回值会作为整个函数的返回值 

![img](https://cdn.nlark.com/yuque/0/2023/png/34886243/1673587611232-4ac37c27-613a-483c-ae3f-27a7d0aad067.png)

◼ **优化三: 如果函数执行体只有返回一个对象, 那么需要给这个对象加上()**

![img](https://cdn.nlark.com/yuque/0/2023/png/34886243/1673587619260-f47db6f6-3682-41e3-b66a-c5c441e3e9d3.png)

## this规则之外 - ES6箭头函数

◼ **箭头函数不使用this的四种标准规则（也就是不绑定this），而是根据外层作用域来决定this。** 

◼ **我们来看一个模拟网络请求的案例：** 

 这里我使用setTimeout来模拟网络请求，请求到数据后如何可以存放到data中呢？ 

 我们需要拿到obj对象，设置data； 

 但是直接拿到的this是window，我们需要在外层定义：var _this = this 

 在setTimeout的回调函数中使用_this就代表了obj对象

![img](https://cdn.nlark.com/yuque/0/2023/png/34886243/1673587649663-083f248e-e092-4968-bd39-aabb6dd55090.png)

## ES6箭头函数this

◼ **之前的代码在ES6之前是我们最常用的方式，从ES6开始，我们会使用箭头函数：** 

 为什么在setTimeout的回调函数中可以直接使用this呢？ 

 因为箭头函数并不绑定this对象，那么this引用就会从上层作用于中找到对应的this

![img](https://cdn.nlark.com/yuque/0/2023/png/34886243/1673587674531-123c08f0-17fd-464b-83ac-7b52dc8e0107.png)

# this面试题分析

 面试题一： 

![image.png](https://cdn.nlark.com/yuque/0/2023/png/34886243/1673587689712-d2e5101e-f128-41ef-8e9b-e64bf1af942a.png)



 面试题二： 

![image.png](https://cdn.nlark.com/yuque/0/2023/png/34886243/1673587706866-f4293627-3a40-4a0d-815b-299b472c2748.png)



 面试题三： 

![image.png](https://cdn.nlark.com/yuque/0/2023/png/34886243/1673587718864-8b458077-128c-4579-86f1-1d8d83e61b3d.png)



 面试题四： 

![image.png](https://cdn.nlark.com/yuque/0/2023/png/34886243/1673587730287-b9736356-d0a1-401b-a218-b98b840dc9b8.png)

